# -*- coding: utf-8 -*-
"""Untitled13.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Ls_GXOScnFLmZK_q-GHtmU3W1-ydbVxF
"""

# %% [markdown]
# # üè≠ PROTOTYPE: AI-POWERED CNC VIRTUAL LEARNING
#
# Fitur:
# 1. CNC Simulator 2D/3D
# 2. AI G-code Generator
# 3. Virtual Quality Control
# 4. Predictive Maintenance Simulation
#
# Instalasi Library

# Install required libraries
!pip install numpy matplotlib plotly ipywidgets flask-ngrok scikit-learn tensorflow streamlit gradio -q
!apt-get install -y xvfb libgtk2.0-0 libgconf-2-4 libxss1 libnss3 libasound2 > /dev/null 2>&1

import numpy as np
import matplotlib.pyplot as plt
import plotly.graph_objects as go
from ipywidgets import interact, widgets
import ipywidgets as widgets
from IPython.display import display, HTML

class SimpleCNCSimulator:
    def __init__(self):
        self.x_pos = 0
        self.y_pos = 0
        self.z_pos = 0
        self.tool_path = []

    def execute_gcode(self, gcode):
        """Simulate G-code execution"""
        commands = gcode.strip().split('\n')
        path = []

        for cmd in commands:
            if 'G00' in cmd or 'G01' in cmd:  # Rapid/Linear move
                if 'X' in cmd:
                    self.x_pos = float(cmd.split('X')[1].split()[0])
                if 'Y' in cmd:
                    self.y_pos = float(cmd.split('Y')[1].split()[0])
                if 'Z' in cmd:
                    self.z_pos = float(cmd.split('Z')[1].split()[0])

                path.append((self.x_pos, self.y_pos, self.z_pos))

        self.tool_path = path
        return path

    def visualize_2d(self):
        """2D visualization of tool path"""
        if not self.tool_path:
            print("No tool path to visualize")
            return

        x_vals = [p[0] for p in self.tool_path]
        y_vals = [p[1] for p in self.tool_path]

        fig, ax = plt.subplots(figsize=(10, 8))
        ax.plot(x_vals, y_vals, 'b-', linewidth=2, label='Tool Path')
        ax.scatter(x_vals, y_vals, c='red', s=50, zorder=5)

        # Add start and end markers
        ax.scatter(x_vals[0], y_vals[0], c='green', s=200, marker='o', label='Start')
        ax.scatter(x_vals[-1], y_vals[-1], c='red', s=200, marker='s', label='End')

        ax.set_xlabel('X Position (mm)')
        ax.set_ylabel('Y Position (mm)')
        ax.set_title('CNC Tool Path Simulation')
        ax.grid(True)
        ax.legend()
        ax.axis('equal')
        plt.show()

    def visualize_3d(self):
        """3D visualization using Plotly"""
        if not self.tool_path:
            print("No tool path to visualize")
            return

        x_vals = [p[0] for p in self.tool_path]
        y_vals = [p[1] for p in self.tool_path]
        z_vals = [p[2] for p in self.tool_path]

        fig = go.Figure(data=[
            go.Scatter3d(
                x=x_vals, y=y_vals, z=z_vals,
                mode='lines+markers',
                line=dict(width=4, color='blue'),
                marker=dict(size=4, color=z_vals, colorscale='Viridis')
            )
        ])

        fig.update_layout(
            title='3D CNC Tool Path Simulation',
            scene=dict(
                xaxis_title='X (mm)',
                yaxis_title='Y (mm)',
                zaxis_title='Z (mm)',
                camera=dict(eye=dict(x=1.5, y=1.5, z=1.5))
            ),
            width=800,
            height=600
        )

        fig.show()

# Instantiate and test
simulator = SimpleCNCSimulator()

# Sample G-code
sample_gcode = """
G00 X0 Y0 Z5
G01 X10 Y10 Z0
G01 X30 Y10 Z0
G01 X30 Y30 Z0
G01 X10 Y30 Z0
G01 X10 Y10 Z0
G00 X0 Y0 Z5
"""

# Execute and visualize
path = simulator.execute_gcode(sample_gcode)
print(f"Tool Path Points: {path}")
simulator.visualize_2d()
simulator.visualize_3d()

# %% [markdown]
# ## ü§ñ AI G-code Assistant
# AI untuk generate, optimize, dan debug G-code

import numpy as np

class AICodeAssistant:
    def __init__(self):
        self.common_patterns = {
            'square': self.generate_square,
            'circle': self.generate_circle,
            'triangle': self.generate_triangle,
            'pocket': self.generate_pocket
        }

    def generate_square(self, size=20, depth=5):
        """Generate square milling pattern"""
        gcode = f"""
G00 X0 Y0 Z5
G01 Z-{depth} F100
G01 X{size} Y0 F200
G01 X{size} Y{size}
G01 X0 Y{size}
G01 X0 Y0
G00 Z5
"""
        return gcode

    def generate_circle(self, radius=15, depth=5, resolution=36):
        """Generate circular milling pattern"""
        gcode_lines = []
        gcode_lines.append(f"G00 X0 Y0 Z5")
        gcode_lines.append(f"G01 Z-{depth} F100") # Plunge to depth

        # Start at (radius, 0) for the circle
        start_x = radius
        start_y = 0
        gcode_lines.append(f"G01 X{start_x} Y{start_y} F200")

        # Iterate to create points on the circle
        for i in range(1, resolution + 1):
            angle = 2 * np.pi * i / resolution
            x = radius * np.cos(angle)
            y = radius * np.sin(angle)
            gcode_lines.append(f"G01 X{x:.4f} Y{y:.4f}")

        gcode_lines.append(f"G00 Z5") # Retract
        gcode = "\n".join(gcode_lines)
        return gcode

    def generate_triangle(self, side_length=20, depth=5):
        """Generate triangle milling pattern"""
        # An equilateral triangle starting from (0,0)
        height = side_length * np.sqrt(3) / 2
        gcode = f"""
G00 X0 Y0 Z5
G01 Z-{depth} F100
G01 X0 Y0 F200
G01 X{side_length} Y0
G01 X{side_length/2:.4f} Y{height:.4f}
G01 X0 Y0
G00 Z5
"""
        return gcode

    def generate_pocket(self, width=20, height=20, depth=5, stepover=5):
        """Generate pocket milling pattern"""
        gcode_lines = []
        gcode_lines.append(f"G00 X0 Y0 Z5")
        gcode_lines.append(f"G01 Z-{depth} F100")

        # Simple zig-zag pocket
        for y_offset in np.arange(0, height + stepover, stepover):
            if int(y_offset / stepover) % 2 == 0: # Even pass, move right
                gcode_lines.append(f"G01 X0 Y{y_offset:.4f} F200")
                gcode_lines.append(f"G01 X{width:.4f} Y{y_offset:.4f}")
            else: # Odd pass, move left
                gcode_lines.append(f"G01 X{width:.4f} Y{y_offset:.4f}")
                gcode_lines.append(f"G01 X0 Y{y_offset:.4f}")

        gcode_lines.append(f"G00 Z5")
        gcode = "\n".join(gcode_lines)
        return gcode

# %% [markdown]
# ## üîç Virtual Quality Control with Computer Vision Simulation

import matplotlib.pyplot as plt
from skimage import draw
import cv2
from sklearn.ensemble import IsolationForest

class VirtualQualityControl:
    def __init__(self):
        self.defect_types = ['scratch', 'dent', 'burr', 'dimension_error']

    def simulate_workpiece(self, width=400, height=400, has_defect=True):
        """Simulate a machined workpiece with/without defects"""
        workpiece = np.ones((height, width, 3), dtype=np.uint8) * 200  # Gray background

        # Draw a machined part (rectangle)
        cv2.rectangle(workpiece, (50, 50), (350, 350), (150, 150, 150), -1)
        cv2.rectangle(workpiece, (50, 50), (350, 350), (100, 100, 100), 5)

        # Add some machining marks
        for i in range(60, 340, 20):
            cv2.line(workpiece, (i, 60), (i, 340), (180, 180, 180), 1)

        if has_defect:
            # Add simulated defects
            # Scratch
            cv2.line(workpiece, (200, 100), (250, 120), (50, 50, 50), 3)

            # Dent
            cv2.circle(workpiece, (280, 280), 15, (80, 80, 80), -1)

            # Burr (rough edge)
            points = np.array([[100, 300], [110, 310], [120, 305], [130, 315]], np.int32)
            cv2.fillPoly(workpiece, [points], (120, 120, 120))

        return workpiece

    def detect_defects(self, image):
        """Simple defect detection using edge detection"""
        gray = cv2.cvtColor(image, cv2.COLOR_RGB2GRAY)

        # Edge detection
        edges = cv2.Canny(gray, 50, 150)

        # Find contours
        contours, _ = cv2.findContours(edges, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

        # Filter small contours (likely defects)
        defect_contours = []
        for contour in contours:
            area = cv2.contourArea(contour)
            if 10 < area < 500:  # Defect size range
                defect_contours.append(contour)

        return defect_contours

    def visualize_inspection(self, workpiece, defects):
        """Visualize inspection results"""
        fig, axes = plt.subplots(1, 3, figsize=(15, 5))

        # Original workpiece
        axes[0].imshow(workpiece)
        axes[0].set_title('Workpiece Image')
        axes[0].axis('off')

        # Edge detection
        gray = cv2.cvtColor(workpiece, cv2.COLOR_RGB2GRAY)
        edges = cv2.Canny(gray, 50, 150)
        axes[1].imshow(edges, cmap='gray')
        axes[1].set_title('Edge Detection')
        axes[1].axis('off')

        # Defect highlighting
        result = workpiece.copy()
        cv2.drawContours(result, defects, -1, (255, 0, 0), 2)

        # Add defect count
        cv2.putText(result, f'Defects: {len(defects)}', (10, 30),
                   cv2.FONT_HERSHEY_SIMPLEX, 1, (255, 0, 0), 2)

        axes[2].imshow(result)
        axes[2].set_title(f'Defect Detection: {len(defects)} found')
        axes[2].axis('off')

        plt.tight_layout()
        plt.show()

        return len(defects)

# Test Quality Control
qc = VirtualQualityControl()

# Simulate workpieces with and without defects
print("=== Quality Control Simulation ===")
print("\n1. Workpiece WITHOUT defects:")
good_workpiece = qc.simulate_workpiece(has_defect=False)
defects_good = qc.detect_defects(good_workpiece)
num_defects_good = qc.visualize_inspection(good_workpiece, defects_good)
print(f"   Defects detected: {num_defects_good}")

print("\n2. Workpiece WITH defects:")
bad_workpiece = qc.simulate_workpiece(has_defect=True)
defects_bad = qc.detect_defects(bad_workpiece)
num_defects_bad = qc.visualize_inspection(bad_workpiece, defects_bad)
print(f"   Defects detected: {num_defects_bad}")

# %% [markdown]
# ## üìà Predictive Maintenance Simulation

import pandas as pd
from sklearn.preprocessing import StandardScaler
from sklearn.svm import OneClassSVM
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots

class PredictiveMaintenanceSimulator:
    def __init__(self):
        self.sensors = ['vibration', 'temperature', 'power_consumption', 'spindle_speed']

    def generate_sensor_data(self, days=30, failure_day=25):
        """Generate simulated sensor data with failure pattern"""
        np.random.seed(42)

        # Changed 'H' to 'h' to address FutureWarning
        dates = pd.date_range(start='2024-01-01', periods=days*24, freq='h')

        data = {
            'timestamp': dates,
            'vibration': np.random.normal(2.0, 0.2, len(dates)),
            'temperature': np.random.normal(45, 2, len(dates)),
            'power_consumption': np.random.normal(3.5, 0.3, len(dates)),
            'spindle_speed': np.random.normal(3000, 100, len(dates))
        }

        # Introduce gradual degradation
        failure_start = failure_day * 24
        for i in range(failure_start, len(dates)):
            # Increase vibration
            data['vibration'][i] += np.random.uniform(0.1, 0.5)

            # Increase temperature
            data['temperature'][i] += np.random.uniform(0.5, 2)

            # Decrease spindle speed consistency
            data['spindle_speed'][i] += np.random.uniform(-50, 50)

        # Sudden failure at the end
        if failure_day < days:
            failure_idx = failure_day * 24
            data['vibration'][failure_idx:] += np.random.uniform(1, 3, len(dates)-failure_idx)
            data['temperature'][failure_idx:] += np.random.uniform(5, 10, len(dates)-failure_idx)

        df = pd.DataFrame(data)
        df.set_index('timestamp', inplace=True)
        return df

    def detect_anomalies(self, sensor_data):
        """Detect anomalies using machine learning"""
        # Prepare data
        X = sensor_data.values

        # Scale data
        scaler = StandardScaler()
        X_scaled = scaler.fit_transform(X)

        # Use One-Class SVM for anomaly detection
        model = OneClassSVM(nu=0.05, kernel='rbf', gamma=0.1)
        predictions = model.fit_predict(X_scaled)

        # -1 for anomalies, 1 for normal
        anomalies = predictions == -1

        return anomalies

    def visualize_predictive_maintenance(self, sensor_data, anomalies):
        """Visualize sensor data with anomalies"""
        fig = make_subplots(
            rows=len(self.sensors), cols=1,
            subplot_titles=[f'{sensor.replace("_", " ").title()}' for sensor in self.sensors],
            vertical_spacing=0.1
        )

        for i, sensor in enumerate(self.sensors, 1):
            # Normal data
            normal_data = sensor_data[~anomalies][sensor]
            normal_dates = sensor_data[~anomalies].index

            # Anomaly data
            anomaly_data = sensor_data[anomalies][sensor]
            anomaly_dates = sensor_data[anomalies].index

            # Add normal trace
            fig.add_trace(
                go.Scatter(
                    x=normal_dates, y=normal_data,
                    mode='lines',
                    name='Normal',
                    line=dict(color='blue', width=1),
                    showlegend=True if i == 1 else False
                ),
                row=i, col=1
            )

            # Add anomaly trace
            fig.add_trace(
                go.Scatter(
                    x=anomaly_dates, y=anomaly_data,
                    mode='markers',
                    name='Anomaly',
                    marker=dict(color='red', size=8, symbol='x'),
                    showlegend=True if i == 1 else False
                ),
                row=i, col=1
            )

        fig.update_layout(
            height=800,
            title_text='Predictive Maintenance: Sensor Data with Anomaly Detection',
            showlegend=True
        )

        # Add vertical line for predicted failure and separate annotation
        if len(anomaly_dates) > 0:
            first_anomaly = anomaly_dates[0]
            # Draw the vertical line
            fig.add_vline(
                x=first_anomaly.to_pydatetime(),
                line_dash="dash",
                line_color="orange"
            )
            # Add the annotation separately
            fig.add_annotation(
                x=first_anomaly.to_pydatetime(),
                y=1.05, # Position above the plot, adjust as needed
                xref="x",
                yref="paper",
                text="First Anomaly Detected",
                showarrow=False,
                font=dict(color="orange"),
                align="right",
                valign="top"
            )

        fig.show()

        # Calculate time to failure prediction
        if len(anomaly_dates) > 0:
            first_anomaly_time = anomaly_dates[0]
            data_end_time = sensor_data.index[-1]
            time_to_failure = (data_end_time - first_anomaly_time).total_seconds() / 3600

            print(f"\n=== Maintenance Prediction ===")
            print(f"First anomaly detected at: {first_anomaly_time}")
            print(f"Time since first anomaly: {time_to_failure:.1f} hours")
            print(f"Recommended maintenance: Within next {max(24 - time_to_failure, 0):.0f} hours")

            if time_to_failure > 24:
                print("‚ö†Ô∏è  CRITICAL: Immediate maintenance required!")
            elif time_to_failure > 12:
                print("‚ö†Ô∏è  WARNING: Schedule maintenance soon")
            else:
                print("‚úÖ Normal operation")

# Test Predictive Maintenance
pm = PredictiveMaintenanceSimulator()

print("=== Predictive Maintenance Simulation ===")
print("Generating 30 days of sensor data...")

sensor_data = pm.generate_sensor_data(days=30, failure_day=25)
print(f"Generated {len(sensor_data)} data points")

print("\nDetecting anomalies...")
anomalies = pm.detect_anomalies(sensor_data)
num_anomalies = sum(anomalies)
print(f"Anomalies detected: {num_anomalies} ({num_anomalies/len(anomalies)*100:.1f}%)")

# Visualize results
pm.visualize_predictive_maintenance(sensor_data, anomalies)

# %% [markdown]
# ## üåê Interactive Web Interface with Gradio

import gradio as gr

# Create interactive interface
def create_interactive_interface():
    simulator = SimpleCNCSimulator()
    ai_assistant = AICodeAssistant()

    def run_simulation(gcode_input):
        """Run CNC simulation with input G-code"""
        path = simulator.execute_gcode(gcode_input)
        simulator.visualize_2d()
        return f"Simulation completed with {len(path)} points"

    def generate_shape(shape_type, size):
        """Generate G-code for different shapes"""
        if shape_type == "square":
            return ai_assistant.generate_square(size=size)
        elif shape_type == "circle":
            return ai_assistant.generate_circle(radius=size)
        else:
            return "Select a shape type"

    def check_quality(image):
        """Check quality of uploaded workpiece image"""
        if image is None:
            return "Please upload an image"

        # Convert to numpy array
        image_np = np.array(image)

        # Detect defects
        qc = VirtualQualityControl()
        defects = qc.detect_defects(image_np)

        # Create visualization
        fig, ax = plt.subplots(figsize=(6, 6))
        ax.imshow(image_np)
        ax.set_title(f'Defects Found: {len(defects)}')
        ax.axis('off')

        # Highlight defects
        for defect in defects:
            x, y, w, h = cv2.boundingRect(defect)
            rect = plt.Rectangle((x, y), w, h, linewidth=2, edgecolor='r', facecolor='none')
            ax.add_patch(rect)

        return fig

    # Create Gradio interface
    with gr.Blocks(title="AI CNC Learning Platform") as demo:
        gr.Markdown("# üè≠ AI CNC Virtual Learning Platform")
        gr.Markdown("Proof of Concept - Interactive CNC Simulator")

        with gr.Tab("CNC Simulator"):
            with gr.Row():
                with gr.Column():
                    gcode_input = gr.Textbox(
                        label="G-code Input",
                        value=sample_gcode,
                        lines=10
                    )
                    run_btn = gr.Button("Run Simulation", variant="primary")

                with gr.Column():
                    output = gr.Textbox(label="Simulation Results", lines=3)

            run_btn.click(run_simulation, inputs=[gcode_input], outputs=[output])

        with gr.Tab("AI Code Assistant"):
            with gr.Row():
                with gr.Column():
                    shape_type = gr.Dropdown(
                        choices=["square", "circle", "triangle"],
                        label="Select Shape",
                        value="square"
                    )
                    size = gr.Slider(minimum=10, maximum=100, value=30, label="Size/Radius")
                    generate_btn = gr.Button("Generate G-code", variant="primary")

                with gr.Column():
                    generated_code = gr.Textbox(label="Generated G-code", lines=10)

            generate_btn.click(generate_shape, inputs=[shape_type, size], outputs=[generated_code])

        with gr.Tab("Quality Control"):
            with gr.Row():
                image_input = gr.Image(label="Upload Workpiece Image", type="pil")
                check_btn = gr.Button("Check Quality", variant="primary")

            with gr.Row():
                result_plot = gr.Plot(label="Inspection Results")

            check_btn.click(check_quality, inputs=[image_input], outputs=[result_plot])

        with gr.Tab("Predictive Maintenance"):
            gr.Markdown("### Machine Health Monitoring")
            days_input = gr.Slider(minimum=7, maximum=60, value=30, label="Days to Simulate")
            simulate_btn = gr.Button("Simulate Sensor Data", variant="primary")

            output_plot = gr.Plot(label="Sensor Data with Anomalies")

            def simulate_maintenance(days):
                pm = PredictiveMaintenanceSimulator()
                sensor_data = pm.generate_sensor_data(days=int(days), failure_day=int(days*0.8))
                anomalies = pm.detect_anomalies(sensor_data)

                fig = make_subplots(rows=2, cols=2, subplot_titles=pm.sensors)

                for i, sensor in enumerate(pm.sensors, 1):
                    row = (i-1)//2 + 1
                    col = (i-1)%2 + 1

                    normal_data = sensor_data[~anomalies][sensor]
                    anomaly_data = sensor_data[anomalies][sensor]

                    fig.add_trace(
                        go.Scatter(x=normal_data.index, y=normal_data, mode='lines', name='Normal'),
                        row=row, col=col
                    )
                    fig.add_trace(
                        go.Scatter(x=anomaly_data.index, y=anomaly_data, mode='markers',
                                  name='Anomaly', marker=dict(color='red', symbol='x')),
                        row=row, col=col
                    )

                fig.update_layout(height=600, showlegend=False)
                return fig

            simulate_btn.click(simulate_maintenance, inputs=[days_input], outputs=[output_plot])

    return demo

# Launch the interface
print("Launching interactive interface...")
demo = create_interactive_interface()

# To run in Colab, we need to use ngrok for public URL
from google.colab import output
output.enable_custom_widget_manager()

# Launch with public URL
demo.launch(share=True, debug=True)

"""# üè≠ PROTOTYPE: AI-POWERED CNC VIRTUAL LEARNING

## Pendahuluan
Proyek ini adalah *Proof of Concept* (PoC) untuk platform pembelajaran virtual CNC bertenaga AI, yang  Tujuannya adalah untuk mendemonstrasikan bagaimana teknologi AI dan simulasi dapat digunakan untuk meningkatkan pendidikan dan pelatihan di bidang manufaktur CNC, khususnya untuk sekolah kejuruan (SMK).

## Fitur Utama
1.  **CNC Simulator 2D/3D**: Memvisualisasikan jalur alat (tool path) G-code secara interaktif dalam dua atau tiga dimensi.
2.  **AI G-code Generator**: Asisten AI untuk menghasilkan, mengoptimalkan, dan membantu debugging G-code untuk berbagai bentuk geometris.
3.  **Virtual Quality Control**: Mensimulasikan inspeksi kualitas benda kerja menggunakan teknik Computer Vision untuk mendeteksi cacat.
4.  **Predictive Maintenance Simulation**: Mensimulasikan pemantauan kesehatan mesin dan memprediksi potensi kegagalan berdasarkan data sensor, menggunakan algoritma pembelajaran mesin untuk deteksi anomali.

## Instalasi

### Lingkungan Python
Jika Anda ingin menjalankan proyek ini di lingkungan Python lokal (di luar Google Colab), pastikan Anda memiliki Python 3.8+ terinstal. Kemudian, Anda dapat menginstal semua dependensi menggunakan pip:

```bash
# Buat virtual environment (opsional, namun disarankan)
python -m venv venv
source venv/bin/activate # Untuk Linux/macOS
# venv\Scripts\activate   # Untuk Windows

# Instal semua library yang dibutuhkan
pip install numpy matplotlib plotly ipywidgets scikit-learn tensorflow gradio streamlit opencv-python
```

## Tujuan Proyek
*   **Meningkatkan Pemahaman Konsep CNC**: Memberikan alat visual dan interaktif untuk memahami prinsip-prinsip dasar CNC dan G-code.
*   **Aplikasi AI dalam Manufaktur**: Mendemonstrasikan potensi AI dalam otomasi pembuatan G-code, kontrol kualitas, dan pemeliharaan prediktif.
*   **Pembelajaran Aksesibel**: Menyediakan platform pembelajaran virtual yang dapat diakses melalui web browser, tanpa memerlukan perangkat keras CNC fisik yang mahal.
*   **Pengembangan Keterampilan**: Membantu siswa SMK dan profesional melatih keterampilan mereka dalam pemrograman CNC dan analisis data mesin.

## Penggunaan dan Reproduksi Proyek

### 1. Menyiapkan Lingkungan

#### Di Lingkungan Python
*   Setelah menginstal dependensi (lihat bagian Instalasi di atas), Anda bisa menjalankan skrip Python secara individual atau mengadaptasi kode sel ke dalam skrip `.py`.
*   Untuk antarmuka Gradio, simpan kode dari sel Gradio (`DHtHAInqTzqT`) ke dalam file `app_gradio.py` dan jalankan `python app_gradio.py`.
*   Untuk aplikasi Streamlit, simpan kode dari sel Streamlit (`6SKZmzncTznK`) ke dalam file `cnc_simulator_app.py` dan jalankan `streamlit run cnc_simulator_app.py`.

### 2. Fitur CNC Simulator
*   Kelas `SimpleCNCSimulator` memungkinkan Anda mengeksekusi G-code dan memvisualisasikan jalur alat.
*   Anda dapat memodifikasi `sample_gcode` di sel `VdaOTioDTz2n` dan menjalankan ulang untuk melihat visualisasi yang berbeda.
*   **Visualisasi**: Visualisasi 2D (menggunakan Matplotlib) dan 3D (menggunakan Plotly), window Matplotlib akan muncul, dan plot Plotly akan terbuka di browser default Anda.
*   **Contoh Visualisasi**: ![Contoh Visualisasi CNC Simulator](https://i.imgur.com/example_cnc_sim.png)

### 3. Fitur AI G-code Assistant
*   Kelas `AICodeAssistant` di sel `XRZtmRWHTzzl` menyediakan metode untuk membuat G-code untuk bentuk dasar (persegi, lingkaran, segitiga, pocket).
*   Anda bisa memanggil fungsi-fungsi seperti `ai_assistant.generate_square(size=...)` untuk mendapatkan G-code yang dihasilkan.
*   **Visualisasi**: G-code yang dihasilkan akan ditampilkan sebagai teks. Untuk memvisualisasikannya, Anda bisa menyalin G-code ini ke dalam `SimpleCNCSimulator`.
*   **Contoh Visualisasi**: ![Contoh G-code Assistant](https://i.imgur.com/example_ai_gcode.png)

### 4. Fitur Virtual Quality Control
*   Kelas `VirtualQualityControl` di sel `E_uSZLb7Tzwe` mensimulasikan inspeksi benda kerja.
*   Fungsi `qc.simulate_workpiece(has_defect=True/False)` membuat gambar benda kerja.
*   Fungsi `qc.detect_defects()` akan mengidentifikasi cacat pada gambar yang disimulasikan, dan `qc.visualize_inspection()` akan menampilkan hasilnya.
*   **Visualisasi**: Gambar hasil inspeksi (benda kerja asli, deteksi tepi, dan cacat yang disorot), ini akan muncul di window Matplotlib.
*   **Contoh Visualisasi**: ![Contoh Virtual Quality Control](https://i.imgur.com/example_vqc.png)

### 5. Fitur Predictive Maintenance Simulation
*   Kelas `PredictiveMaintenanceSimulator` di sel `07283e14` mensimulasikan data sensor dan mendeteksi anomali. Ini sudah mencakup *hyperparameter tuning* untuk model OneClassSVM.
*   Fungsi `pm.generate_sensor_data()` membuat data sensor, dan `pm.detect_anomalies()` mengidentifikasi pola-pola aneh.
*   `pm.visualize_predictive_maintenance()` akan menampilkan grafik sensor dengan anomali yang disorot serta prediksi pemeliharaan.
*   **Visualisasi**: Grafik interaktif dari data sensor dengan anomali yang disorot (menggunakan Plotly), plot ini akan terbuka di browser default Anda.
*   **Contoh Visualisasi**: ![Contoh Predictive Maintenance](https://i.imgur.com/example_pm.png)

### 6. Antarmuka Interaktif (Gradio)
*   Sel `DHtHAInqTzqT` akan meluncurkan antarmuka web Gradio.
*   Setelah sel ini dijalankan, akan muncul tautan publik (biasanya berakhir dengan `.gradio.live`). Buka tautan ini di browser Anda untuk berinteraksi dengan semua fitur proyek dalam satu antarmuka yang ramah pengguna.
*   **Visualisasi**: Semua visualisasi (CNC, QC, PM) akan terintegrasi dan ditampilkan langsung di antarmuka web Gradio.
*   **Contoh Visualisasi**: ![Contoh Gradio Interface](https://i.imgur.com/example_gradio.png)

### 7. Aplikasi Streamlit (Opsional)
*   Sel `6SKZmzncTznK` akan membuat file `cnc_simulator_app.py`.
*   Untuk menjalankan aplikasi Streamlit ini, Anda perlu mengunduh file `.py` tersebut dan menjalankannya secara lokal dengan `streamlit run cnc_simulator_app.py` atau menyebarkannya ke platform seperti Streamlit Cloud. Ini memberikan alternatif untuk akses seluler.
*   **Visualisasi**: Visualisasi akan ditampilkan langsung di antarmuka web Streamlit.
*   **Contoh Visualisasi**: ![Contoh Streamlit App](https://i.imgur.com/example_streamlit.png)

### 8. Pengujian Fungsionalitas Dasar
*   Sel `30vsjAIBTzkn` berisi fungsi `test_all_features()` yang dapat Anda jalankan untuk memverifikasi bahwa semua komponen utama proyek berfungsi dengan benar. Output akan berupa teks konfirmasi di output sel.

## Kontribusi
Proyek ini bersifat prototipe dan terbuka untuk pengembangan lebih lanjut. Ide-ide untuk kontribusi meliputi:
*   Ekspansi pada `AI G-code Assistant` (misalnya, menambahkan lebih banyak bentuk, optimasi jalur alat).
*   Peningkatan model `Virtual Quality Control` (misalnya, menggunakan model deep learning).
*   Penyempurnaan model `Predictive Maintenance` dengan algoritma yang lebih canggih atau data yang lebih kompleks.
*   Perbaikan UI/UX pada antarmuka Gradio atau Streamlit.
*   Implementasi lebih banyak standar industri dan metrik evaluasi.

Selamat mencoba dan berkreasi!

"""

# Commented out IPython magic to ensure Python compatibility.
# # %% [markdown]
# # ## üì± Streamlit App for Mobile Access
# #
# # Streamlit versi lebih sederhana untuk mobile access
# 
# %%writefile cnc_simulator_app.py
# import streamlit as st
# import numpy as np
# import matplotlib.pyplot as plt
# import pandas as pd
# import plotly.graph_objects as go
# from plotly.subplots import make_subplots
# 
# st.set_page_config(
#     page_title="AI CNC Learning Platform",
#     page_icon="üè≠",
#     layout="wide"
# )
# 
# # Title
# st.title("üè≠ AI CNC Virtual Learning Platform - Mobile Edition")
# st.markdown("Proof of Concept for SMK CNC Education")
# 
# # Sidebar
# st.sidebar.header("Navigation")
# section = st.sidebar.radio(
#     "Go to:",
#     ["CNC Simulator", "G-code Assistant", "Quality Control", "Predictive Maintenance"]
# )
# 
# if section == "CNC Simulator":
#     st.header("CNC Tool Path Simulator")
# 
#     col1, col2 = st.columns(2)
# 
#     with col1:
#         st.subheader("G-code Input")
#         sample_code = """G00 X0 Y0 Z5
# G01 X20 Y0 Z0
# G01 X20 Y20 Z0
# G01 X0 Y20 Z0
# G01 X0 Y0 Z0
# G00 X0 Y0 Z5"""
# 
#         gcode = st.text_area("Enter G-code:", value=sample_code, height=200)
# 
#         if st.button("Run Simulation", type="primary"):
#             st.success("Simulation running...")
# 
#     with col2:
#         st.subheader("Visualization")
#         fig, ax = plt.subplots(figsize=(6, 6))
# 
#         # Simple simulation
#         ax.plot([0, 20, 20, 0, 0], [0, 0, 20, 20, 0], 'b-', linewidth=2)
#         ax.scatter([0, 20, 20, 0], [0, 0, 20, 20], c='red', s=50)
#         ax.set_xlabel('X Position')
#         ax.set_ylabel('Y Position')
#         ax.set_title('Tool Path')
#         ax.grid(True)
#         ax.axis('equal')
# 
#         st.pyplot(fig)
# 
# elif section == "G-code Assistant":
#     st.header("AI G-code Assistant")
# 
#     shape = st.selectbox("Select Shape:", ["Square", "Circle", "Triangle"])
#     size = st.slider("Size:", 10, 100, 30)
# 
#     if st.button("Generate G-code"):
#         if shape == "Square":
#             gcode = f"""G00 X0 Y0 Z5
# G01 X{size} Y0 Z0
# G01 X{size} Y{size}
# G01 X0 Y{size}
# G01 X0 Y0
# G00 Z5"""
#         elif shape == "Circle":
#             gcode = f"""G00 X0 Y0 Z5
# G02 X{size} Y0 I{size/2} J0
# G00 Z5"""
#         else:
#             gcode = f"""G00 X0 Y0 Z5
# G01 X{size} Y0 Z0
# G01 X{size/2} Y{size}
# G01 X0 Y0
# G00 Z5"""
# 
#         st.code(gcode, language="gcode")
# 
#         # Visualization
#         fig, ax = plt.subplots(figsize=(6, 6))
#         if shape == "Square":
#             ax.plot([0, size, size, 0, 0], [0, 0, size, size, 0], 'r-')
#         elif shape == "Circle":
#             circle = plt.Circle((size/2, size/2), size/2, fill=False, color='r')
#             ax.add_artist(circle)
#         else:
#             ax.plot([0, size, size/2, 0], [0, 0, size, 0], 'r-')
# 
#         ax.set_xlim(-5, size+5)
#         ax.set_ylim(-5, size+5)
#         ax.set_aspect('equal')
#         ax.grid(True)
#         st.pyplot(fig)
# 
# elif section == "Quality Control":
#     st.header("Virtual Quality Control")
# 
#     uploaded_file = st.file_uploader("Upload workpiece image", type=['png', 'jpg', 'jpeg'])
# 
#     if uploaded_file is not None:
#         col1, col2 = st.columns(2)
# 
#         with col1:
#             st.image(uploaded_file, caption="Uploaded Workpiece", use_column_width=True)
# 
#         with col2:
#             st.subheader("Inspection Results")
# 
#             # Simulated results
#             results = {
#                 "Surface Roughness": "0.8 Œºm (Good)",
#                 "Dimensional Accuracy": "¬±0.01 mm (Excellent)",
#                 "Defects Detected": "2 minor scratches",
#                 "Overall Quality": "Acceptable"
#             }
# 
#             for key, value in results.items():
#                 st.metric(label=key, value=value)
# 
#             st.progress(85, text="Quality Score: 85%")
# 
# else:  # Predictive Maintenance
#     st.header("Predictive Maintenance Dashboard")
# 
#     # Generate simulated data
#     days = st.slider("Days of operation:", 7, 90, 30)
# 
#     if st.button("Generate Maintenance Report"):
#         # Simulate sensor data
#         dates = pd.date_range(start='2024-01-01', periods=days, freq='D')
#         vibration = np.random.normal(2.0, 0.3, days) + np.linspace(0, 1, days)
#         temperature = np.random.normal(45, 3, days) + np.linspace(0, 5, days)
# 
#         fig = make_subplots(rows=2, cols=1, subplot_titles=['Vibration Level', 'Temperature'])
# 
#         fig.add_trace(
#             go.Scatter(x=dates, y=vibration, mode='lines+markers', name='Vibration'),
#             row=1, col=1
#         )
# 
#         fig.add_trace(
#             go.Scatter(x=dates, y=temperature, mode='lines+markers', name='Temperature'),
#             row=2, col=1
#         )
# 
#         # Add threshold lines
#         fig.add_hline(y=3.0, line_dash="dash", line_color="red", row=1, col=1,
#                      annotation_text="Warning Threshold")
#         fig.add_hline(y=50, line_dash="dash", line_color="red", row=2, col=1,
#                      annotation_text="Warning Threshold")
# 
#         fig.update_layout(height=600, showlegend=True)
# 
#         st.plotly_chart(fig, use_container_width=True)
# 
#         # Maintenance prediction
#         col1, col2, col3 = st.columns(3)
# 
#         with col1:
#             st.metric("Predicted Failure", "15 days", "from now")
# 
#         with col2:
#             st.metric("Maintenance Urgency", "Medium", "priority")
# 
#         with col3:
#             st.metric("Recommended Action", "Schedule maintenance", "within 7 days")
# 
# # Footer
# st.markdown("---")
# st.markdown("**Prototype for SMK CNC Education** | Powered by AI & Simulation")
# 
# print("Streamlit app created! To run: streamlit run cnc_simulator_app.py")

# %% [markdown]
# ## üöÄ Installation & Running Instructions

# 1. Save all code cells above
# 2. Run each cell sequentially
# 3. For Gradio interface, it will provide a public URL
# 4. For Streamlit, run in separate environment

# Quick test function
def test_all_features():
    print("Testing all prototype features...")

    # Test CNC Simulator
    simulator = SimpleCNCSimulator()
    path = simulator.execute_gcode(sample_gcode)
    print(f"‚úì CNC Simulator: {len(path)} points generated")

    # Test AI Assistant
    ai = AICodeAssistant()
    code = ai.generate_square()
    print(f"‚úì AI Assistant: G-code generated ({len(code.split())} lines)")

    # Test Quality Control
    qc = VirtualQualityControl()
    workpiece = qc.simulate_workpiece()
    defects = qc.detect_defects(workpiece)
    print(f"‚úì Quality Control: {len(defects)} defects detected")

    # Test Predictive Maintenance
    pm = PredictiveMaintenanceSimulator()
    data = pm.generate_sensor_data(days=10)
    anomalies = pm.detect_anomalies(data)
    print(f"‚úì Predictive Maintenance: {sum(anomalies)} anomalies found")

    print("\n‚úÖ All prototype features working correctly!")
    return True

# Run tests
test_all_features()



